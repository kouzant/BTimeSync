\documentclass{article}
\usepackage{xgreek}
\usepackage{xltxtra}
\usepackage{xunicode}
\usepackage{graphicx}
\usepackage{listings}
\setmainfont[Mapping=tex-text]{GFS Didot}
\begin{document}
\include{titlepage}
\tableofcontents
\newpage
\section{Εισαγωγή}
Ο συγχρονισμός της ώρας στην επιστήμη των υπολογιστών είναι ένα πρόβλημα που
έχει ως δεδομένο ότι τα ρολόγια διάφορων υπολογιστών διαφέρουν. Ακόμα και αν
τα ρολόγια συγχρονιστούν σωστά εξ' αρχής, είναι δύσκολο να παραμείνουν
συγχρονισμένα λόγω της διαφοράς συχνοτήτων τους. Στα κεντρικοποιημένα συστήματα,
η λύση του προβλήματος είναι σχετικά απλή. Χρησιμοποιείται ένας κεντρικός
εξυπηρετητής όπου παρέχει την ώρα στους υπολογιστές ενός δικτύου. Με αυτό τον
τρόπο όλοι οι υπολογιστές στο δίκτυο θα έχουν την ίδια ώρα. Στα κατανεμημένα
συστήματα αντιθέτως η λύση δεν είναι τόσο απλή καθώς δεν είναι γνωστή εξ' αρχής η
σωστή ώρα. Συγχρόνως, όσο δύσκολος κι αν είναι ο συγχρονισμός στα κατανεμημένα
συστήματα είναι απαραίτητος. Είναι σημαντικό να μην επιτρέπεται η ταυτόχρονη
προσπέλαση ενός κοινόχρηστου πόρου όπως και η ανάγκη συμφωνίας πολλών διεργασιών
σχετικά με τη χρονική σειρά διάφορων συμβάντων.

\section{Περιγραφή Αλγορίθμου}
Στον αλγόριθμο του Berkeley υπάρχει ένας διακομιστής ώρας ο οποίος ανά τακτά
διαστήματα διενεργεί ελέγχους σε κάθε μηχάνημα. Κάθε μηχάνημα στέλνει την ώρα
που έχει στον διακομιστή, ο δαίμονας -- διακομιστής υπολογίζει μία μέση τιμή και
στέλνει σε κάθε μηχάνημα μία διόρθωση. Η διόρθωση μπορεί να είναι θετική, δηλαδή
να προσθέσουν χρόνο στο ρολόι ή αρνητική, δηλαδή να αφαιρέσουν χρόνο από το
ρολόι. Η διόρθωση είναι διαφορά της μέσης τιμής από την ώρα του κάθε πελάτη. Για
τον υπολογισμό του παραπάνω μέσου όρου, χρησιμοποιείται ένα κατώφλι. Αν κάποια
τιμή ενός πελάτη είναι πολύ ακραία, τότε δεν λαμβάνεται υπόψη στον υπολογισμό
του μέσου όρου. Με αυτό τον τρόπο αποφεύγεται η ακραία απόκλιση του χρόνου του
συστήματος λόγω μίας ακραίας τιμής του ρολογιού ενός πελάτη.

Για την υλοποίηση του παραπάνω αλγορίθμου χρησιμοποιούνται διάφοροι άλλοι
αλγόριθμοι για την εκλογή αρχηγού και για τον υπολογισμό της διόρθωσης του
ρολογιού. Οι αλγόριθμοι αυτοί παρουσιάζονται παρακάτω.

\subsection{Ο αλγόριθμος του Christian}
Ο αλγόριθμος του Christian χρησιμοποιείται για τον υπολογισμό της διόρθωσης που
θα στείλει πίσω στους πελάτες ο διακομιστής. Ο αλγόριθμος αυτός δουλεύει μεταξύ
ενός πελάτη \emph{C} και ενός εξυπηρετητή \emph{S} ο οποίος είναι συνδεδεμένος
με κάποια εξωτερική πηγή συγχρονισμού του ρολογιού του (UTC). Συνοπτικά η διαδικασία που
ακολουθείται είναι η παρακάτω:
\begin{itemize}
    \item Ο \emph{C} ζητάει την ώρα από τον \emph{S}.
    \item Αφού λάβει την αίτηση ο \emph{S}, ετοιμάζει την απάντηση και
επιστρέφει τη δικιά του ώρα \emph{T} στον \emph{C}.
    \item Ο \emph{C} αφού λάβει την απάντηση ορίζει την ώρα του ως \emph{T +
RTT/2}
\end{itemize}

Ο \emph{C} θα πρέπει να κρατάει κάποια εγγραφή με το \emph{RTT} (Round-Trip Time) μεταξύ του
\emph{C} και του \emph{S} ούτως ώστε μετά να θέσει το ρολόι του στην τιμή
\emph{T + RTT/2}. Αυτή η μέθοδος υποθέτει ότι το \emph{RTT} χωρίζεται ισόποσα
μεταξύ της αίτησης και της απάντησης το οποίο δεν ισχύει πάντα, αλλά μπορούμε με
ασφάλεια να θεωρήσουμε ότι ισχύει σε ένα τοπικό δίκτυο.

\subsubsection{Round-Trip Time}
Για κάθε σύνδεση το TCP διατηρεί μια μεταβλητή, την \emph{RTT}, η οποία είναι η
καλύτερη τρέχουσα εκτίμηση του χρόνου διαδρομής μετ' επιστροφής ως τον
αντίστοιχο προορισμό. Ουσιαστικά είναι ο χρόνος που χρειάζεται για ένα πακέτο να
πάει από ένα κόμβο σε έναν άλλο και να επιστρέψει. Ο χρόνος αυτός
χρησιμοποιείται και από την εντολή \emph{ping}. Δίκτυα με υψηλό εύρος ζώνης και
υψηλό \emph{RTT} μπορούν να μεταφέρουν με πολύ καλή ποιότητα μεγάλο μέγεθος
δεδομένων κάθε στιγμή. Το \emph{RTT} υπολογίζεται από τον παρακάτω τύπο:
\[ RTT = \alpha * Old\_RTT + (1 - \alpha) * New\_RTT\]
όπου το $\alpha$ είναι ένας παράγοντας εξομάλυνσης $(0 \leq \alpha < 1)$ ο
οποίος καθορίζει πόσο βάρος δίνεται στην παλιά τιμή. Συνήθως $\alpha =
\frac{7}{8}$

\subsection{Επιλογή ρουλέτας}
Ο αλγόριθμος της επιλογής ρουλέτας (roulette wheel selection) είναι ένας
αλγόριθμος εκλογής αρχηγού που χρησιμοποιείται κατά κόρων στον τομέα της
Τεχνητής Νοημοσύνης. Τα βήματα που ακολουθεί ο αλγόριθμος συνοψίζονται παρακάτω.
\begin{enumerate}
    \item Παράγεται το άθροισμα \emph{S} όλων των τιμών αξιολόγησης των
υποψήφιων αρχηγών.
    \item Επιλέγεται ένας τυχαίος αριθμός \emph{n}, από το 0 μέχρι το \emph{S},
χρησιμοποιώντας συνάρτηση ομοιόμορφης κατανομής για τη δημιουργία των τυχαίων
αριθμών.
    \item Επαναληπτικά εξετάζεται κάθε υποψήφια λύση και η τιμή της προστίθεται
σε ένα καταχωρητή \emph{K}.
    \item Αν η τιμή του \emph{K} γίνει μεγαλύτερη ή ίση του \emph{n}, η λύση
επιλέγεται και ο \emph{K} μηδενίζεται. Στην αντίθετη περίπτωση εκτελείται πάλι
το βήμα 3.
    \item Αν δεν έχει επιλεγεί ικανοποιητικός αριθμός υποψήφιων λύσεων
εκτελείται το βήμα 2, αλλιώς τερματίζει ο αλγόριθμος.
\end{enumerate}

Η λογική του παραπάνω αλγορίθμου είναι ότι οι υποψήφιες λύσεις με μεγάλη τιμή
καταλληλότητας έχουν μεγαλύτερη πιθανότητα να αυξήσουν την τιμή του καταχωρητή
\emph{K} ώστε να υπερβεί την τιμή \emph{n} και συνεπώς να εκλεγούν.

\section{Σχεδιασμός Εφαρμογής}
Ο αλγόριθμος συγχρονισμού της ώρας εφαρμόζεται σε κατανεμημένο σύστημα σε
ομότιμο δίκτυο αστέρα. Κάθε κόμβος του δικτύου χαρακτηρίζεται μοναδικά από 
το SHA-1 hash της ip διεύθυνσή του και ενός τυχαίου αριθμού. Από την αρχή έχει
ορισθεί κάποιος κόμβος ως bootstrap οποίος είναι αρχικά υπεύθυνος για την
εύρεση του επόμενου κόμβου ενός τυχαίου κόμβου και για την διεξαγωγή των πρώτων
εκλογών.

Ένας κόμβος, ο οποίος δεν είναι bootstrap, αρχικά όταν μπαίνει στο δίκτυο
επικοινωνεί με τον bootstrap για να τον ενημερώσει για τον επόμενό του κόμβο. Ο
bootstrap κόμβος έχει μία λίστα με όλα τα UID των κόμβων. Ο επόμενος κόμβος ενός
τυχαίου κόμβου είναι αυτός με το αμέσως μεγαλύτερο UID. Με αυτό τον τρόπο τελικά
όλοι κόμβοι μπορούν έμμεσα να επικοινωνήσουν με τους υπόλοιπους. Στην αρχή
αυτομάτως ο bootstrap κόμβος χρίζεται και αρχηγός.

Σε τακτά χρονικά διαστήματα ο αρχηγός ξεκινάει τη διαδικασία εκλογής νέου
αρχηγού. Η διαδικασία είναι μία παραλλαγή του αλγορίθμου επιλογής ρουλέτας.
Επίσης ο αρχηγός ανά τακτά χρονικά διαστήματα ξεκινάει τη διαδικασία διόρθωσης
των ρολογιών των υπολοίπων κόμβων. Ο αρχηγός αλλάζει στο δίκτυο για διάφορους
λόγους όπως για ασφάλεια. Κάποιος κακόβουλος χρήστης θα μπορούσε να χειρίζεται
τον κόμβο αρχηγό και να ενημερώνει εσφαλμένως για την διόρθωση της ώρας. Στην
περίπτωσή μας όμως αυτό είναι δυνατό μόνο στην περίπτωση που ο κακόβουλος
χρήστης ελέγχει όλους τους κόμβους του δικτύου. Επίσης
ο αρχηγός για κάποιο λόγο μπορεί να πάψει να λειτουργεί. Αν ο αρχηγός είναι
σταθερός τότε οι υπόλοιποι κόμβοι του δικτύου θα παραμείνουν με λανθασμένη ώρα.
Τέλος ενδεχομένως για κάποιο λόγο ο αρχηγός να έχει λανθασμένη ώρα και να κάνει
λανθασμένους υπολογισμούς οπότε θα δώσει λάθος διόρθωση και στους κόμβους. Στην
περίπτωση της τυχαίας αλλαγής του αρχηγού όμως, κάτι τέτοιο δεν είναι δυνατό.

\section{Υλοποίηση}
Κάθε κόμβος έχει ένα configuration file με διάφορες ρυθμίσεις όπως την τιμή του
σφάλματος που θα προσθέσει στο ρολόι του, η θύρα που θα τρέχει το RMI registry,
η θύρα που θα τρέχει ο TCP εξυπηρετητής, την ip διεύθυνση του bootstrap κόμβου
και την θύρα που τρέχει το RMI service στον bootstrap. Αρχικά λοιπόν η εφαρμογή
διαβάζει το αρχείο αυτό από την κλάση \emph{ConfigParser} και ορίζει κατάλληλα ορισμένες μεταβλητές. Στη συνέχεια
κάνει bind τα τρία RMI services που τρέχει κάθε κόμβος. Το πρώτο είναι το
service που διαχειρίζεται όποια ενέργεια έχει να κάνει με το ρολόι, το δεύτερο
είναι το service που είναι υπεύθυνο για τις ενέργειες του δικτύου και τέλος το
τρίτο service είναι υπεύθυνο για τις εκλογές. Στη συνέχεια δημιουργούνται δύο
threads, το ένα που ανά τακτά χρονικά διαστήματα διεξάγει τις εκλογές και το
δεύτερο που ανά τακτά χρονικά διαστήματα διορθώνει το ρολόι στους υπόλοιπους
κόμβους.

\subsection{Διαδικασία Εκλογής}
Όπως αναφέρεται και παραπάνω, ανά τακτά χρονικά διαστήματα διενεργούνται
εκλογές. Μόνο ο αρχηγός μπορεί κάθε φορά να ξεκινήσει τη διαδικασία των εκλογών.
Όλες οι λειτουργίες που χρειάζονται για τις εκλογές βρίσκονται στο πακέτο
\emph{election}. Στην αρχή κάθε κόμβος δημιουργεί ένα thread με το instance της
κλάσης \emph{ElectionThread}. Το thread ``ξυπνάει'' κάθε t δευτερόλεπτα και μόνο
αν ο τρέχων κόμβος είναι αρχηγός συνεχίζει, διαφορετικά ``κοιμάται'' πάλι. Στην
περίπτωση που είναι αρχηγός ένας κόμβος τότε υπολογίζει έναν τυχαίο αριθμό που
τον χρησιμοποιεί για κατώφλι για τη διαδικασία εκλογής του αρχηγού και έναν άλλο
τυχαίο αριθμό ως μέγεθος αξιολόγησης για τον αλγόριθμο επιλογής της ρουλέτας.

Στη συνέχεια κάνει μία RMI κλήση στον επόμενό του κόμβο, στο service που είναι
υπεύθυνο για τις εκλογές. Το service αυτό υλοποιείται από την κλάση
\emph{Procedures}. Η κλήση γίνεται στη μέθοδο \emph{electionMes} όπου στέλνεται
το κατώφλι και ο καταχωρητής με το άθροισμα των αξιολογήσεων Ο τρέχων κόμβος
προσθέτει τη δικιά του αξιολόγηση στον καταχωρητή. Αν ακόμα δεν έχουν ξεπεράσει
το κατώφλι συνεχίζει την προηγούμενη διαδικασία για τον επόμενό του κόμβο. Στην
περίπτωση που ξεπεραστεί το κατώφλι, τότε χρίζεται αυτός αρχηγός, κάνει RMI
κλήσεις τη μέθοδο \emph{newLeader} όπου ενημερώνει τον επόμενο κόμβο ότι υπάρχει
νέος αρχηγός στο δίκτυο. Ο επόμενος συνεχίζει τη διάδοση της είδησης για την
εκλογή νέου αρχηγού.

\subsection{Διόρθωση Ρολογιού}
Ο αρχηγός του δικτύου είναι επιφορτισμένος για την εκτέλεση της διαδικασίας
διόρθωσης των ρολογιών των κόμβων του δικτύου. Ανά πάσα στιγμή υπάρχει αρχηγός
στο δίκτυο οπότε δεν υπάρχει περίπτωση να μην μπορεί να εκτελεστεί η διαδικασία.
Αντίστοιχα με τη διαδικασία εκλογής αρχηγού, οι απαραίτητες λειτουργίες για τη
διόρθωση του ρολογιού βρίσκονται στο πακέτο \emph{time}. Κάθε κόμβος δημιουργεί
ένα thread που έχει τις μεθόδους που χρειάζονται το οποίο είναι ένα instance της
κλάσης \emph{TimeSync}. Το συγκεκριμένο thread ``ξυπνάει'' κάθε τ' δευτερόλεπτα.
Αν ο τρέχων κόμβος δεν είναι αρχηγός, τότε ``ξανακοιμάται''. Σε διαφορετική
περίπτωση για κάθε κόμβο πρέπει να βρει το Round-Trip Time. Για τον λόγο αυτό
για κάθε κόμβο κάνει RMI call στο service που είναι υπεύθυνο για τις λειτουργίες
του δικτύου, το οποίο υλοποιείται από την κλάση \emph{NetOper}, στη μέθοδο
\emph{prepareTcpServer}. Η μέθοδος αυτή υλοποιεί έναν απλό TCP εξυπηρετητή. Ο
αρχηγός μετράει το χρόνο που κάνει ένα πακέτο 56 bytes να πάει στον κόμβο και να
γυρίσει. Ο λόγος που χρησιμοποιείται TCP server και όχι κάποιο RMI call είναι
για να είναι πιο ρεαλιστικό το RTT. Η επιλογή του πακέτου μεγέθους 56 bytes δεν
ήταν τυχαία καθώς η εντολή ping χρησιμοποιεί πακέτα του ιδίου μεγέθους για τον
υπολογισμό του RTT.

Αφού βρει το RTT για κάθε κόμβο τότε κάνει μία RMI κλήση στο service που είναι
υπεύθυνο για τις λειτουργίες του ρολογιού το οποίο υλοποιείται από την κλάση
\emph{TimeOper}. Καλεί την μέθοδο \emph{getNodesTime} όπου επιστρέφει την ώρα
του κόμβου σε milliseconds, σε μορφή EPOCH συν το μέγεθος RTT/2. Αφού υπάρχουν οι τιμές
των ρολογιών για όλους τους κόμβους, υπολογίζεται ένας πρώτος μέσος όρος. Έπειτα
υπολογίζεται ένας δεύτερος μέσος όρος στον οποίο συμμετέχουν μόνο οι κόμβοι που
η τιμή του ρολογιού τους διαφέρει λιγότερο από 5 λεπτά. Με αυτό τον τρόπο
αποκλείονται ενδεχόμενες ακραίες τιμές που θα επηρεάσουν αρνητικά το μέσο όρο.
Εν συνεχεία υπολογίζεται το ποσό της διόρθωσης για κάθε κόμβο, είτε θετικό, είτε
αρνητικό. Τέλος γίνεται RMI κλήση σε κάθε κόμβο, στη μέθοδο
\emph{fixErrorAmount} με το ποσό της διόρθωσης.
\end{document}
